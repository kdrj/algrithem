保证线程安全的四种方式：
            1）synchronized关键字  
            2）lock接口
            3）volatile+CAS【单纯的volatile是轻量级的同步机制保证可见性但是不具备原子性所以要配合CAS来实现线程安全】
            4）atomic原子类【比较冷门，大家可以去看看】


原文：https://blog.csdn.net/zjy15203167987/article/details/82531772




在并发编程中存在线程安全问题，主要原因有：1.存在共享数据 2.多线程共同操作共享数据。


关键字synchronized可以保证在同一时刻，只有一个线程可以执行某个方法或某个代码块，
同时synchronized可以保证一个线程的变化可见（可见性），即可以代替volatile。

synchronized的三种应用方式
java中每一个对象都可以作为锁，这是synchronized实现同步的基础：

1.普通同步方法（实例方法），锁是当前实例对象 ，进入同步代码前要获得当前实例的锁
2.静态同步方法，锁是当前类的class对象 ，进入同步代码前要获得当前类对象的锁
3.同步方法块，锁是括号里面的对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。

synchronized的作用
Synchronized是Java中解决并发问题的一种最常用最简单的方法 ，他可以确保线程互斥的访问同步代码

①多个线程访问同一个对象的同一个方法
分析：当两个线程同时对一个对象的一个方法进行操作，只有一个线程能够抢到锁。因为一个对象只有一把锁，
一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，就不能访问该对象的其他synchronized实例方法，但是可以访问非synchronized修饰的方法

②一个线程获取了该对象的锁之后，其他线程来访问其他synchronized实例方法现象
分析：可以看出其他线程来访问synchronized修饰的其他方法时需要等待线程1先把锁释放
③一个线程获取了该对象的锁之后，其他线程来访问其他非synchronized实例方法现象 举栗
去掉②中方法二的synchronized
分析：当线程1还在执行时，线程2也执行了，所以当其他线程来访问非synchronized修饰的方法时是可以访问的
④当多个线程作用于不同的对象
分析：因为两个线程作用于不同的对象，获得的是不同的锁，所以互相并不影响

