Java 内存模型中的可见性、原子性和有序性。
可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。
原子是世界上的最小单位，具有不可分割性。
Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 是因为其本身包含“禁止指令重排序”的语义



线程的生命周期包含5个阶段，包括：新建、就绪、运行、阻塞、销毁。
   新建：就是刚使用new方法，new出来的线程；
   就绪：就是调用的线程的start()方法后，这时候线程处于等待CPU分配资源阶段，谁先抢的CPU资源，谁开始执行;
   运行：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run方法定义了线程的操作和功能;
   阻塞：在运行状态的时候，可能因为某些原因导致运行状态的线程变成了阻塞状态，比如sleep()、wait()之后线程就处于了阻塞状态，
         这个时候需要其他机制将处于阻塞状态的线程唤醒，比如调用notify或者notifyAll()方法。唤醒的线程不会立刻执行run方法，
         它们要再次等待CPU分配资源进入运行状态;
   销毁：如果线程正常执行完毕后或线程被提前强制性的终止或出现异常导致结束，那么线程就要被销毁，释放资源;


在并发编程中存在线程安全问题，主要原因有：
   1.存在共享数据 
   2.多线程共同操作共享数据。

保证线程安全的四种方式：
   1）synchronized关键字  
   2）lock接口
   3）volatile+CAS【单纯的volatile是轻量级的同步机制保证可见性但是不具备原子性所以要配合CAS来实现线程安全】
   4）atomic原子类【比较冷门，大家可以去看看】

-----------volatile保证变量可见性的原理-----------
-----------什么情况下volatile能够保证线程安全------
volatile关键字不一定能够保证线程安全的问题，其实，在大多数情况下volatile还是可以保证变量的线程安全问题的。
所以，在满足以下两个条件的情况下，volatile就能保证变量的线程安全问题：
         (1)运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。
        (2)变量不需要与其他状态变量共同参与不变约束。


原文：https://blog.csdn.net/zjy15203167987/article/details/82531772





关键字synchronized可以保证在同一时刻，只有一个线程可以执行某个方法或某个代码块，
同时synchronized可以保证一个线程的变化可见（可见性），即可以代替volatile。

synchronized的cpu原语级别实现方式
synchronized代码块主要是由monitorenter和monitorexit这两个原语来实现同步的。当线程进入monitorenter获得执行代码的权利时，其他线程就不能执行里面的
代码，直到锁owner线程执行monitorexit释放锁后，其他线程才可以竞争获得锁。

synchronized的三种应用方式
    1. 修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁。
    2. 修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁。
    3. 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象。

①多个线程访问同一个对象的同一个方法
分析：当两个线程同时对一个对象的一个方法进行操作，只有一个线程能够抢到锁。因为一个对象只有一把锁，
一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，就不能访问该对象的其他synchronized实例方法，但是可以访问非synchronized修饰的方法

②一个线程获取了该对象的锁之后，其他线程来访问其他synchronized实例方法现象
分析：可以看出其他线程来访问synchronized修饰的其他方法时需要等待线程1先把锁释放
③一个线程获取了该对象的锁之后，其他线程来访问其他非synchronized实例方法现象 举栗
去掉②中方法二的synchronized
分析：当线程1还在执行时，线程2也执行了，所以当其他线程来访问非synchronized修饰的方法时是可以访问的
④当多个线程作用于不同的对象
分析：因为两个线程作用于不同的对象，获得的是不同的锁，所以互相并不影响

