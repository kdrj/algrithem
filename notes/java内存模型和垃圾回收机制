java内存模型

五大内存区域
    线程私有的：程序计数器，虚拟机栈，本地方法栈
    线程共享的：堆，方法区，直接内存
1 程序计数器
　　程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。
　　有两个作用：
        字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
        在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。
　　注意：程序计数器是唯不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。
2.虚拟机栈
        Java虚拟机栈是由一个个栈帧组成，线程在执行一个方法时，便会向栈中放入一个栈帧，每个栈帧中都拥有局部变量表、操作数栈、动态链接、方法出口信息。
        局部变量表主要存放了编译器可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）和对象引用（reference类型，
        它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。
    Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。
　　    StackOverFlowError：若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，
         就抛出StackOverFlowError异常。
　　    OutOfMemoryError：若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。
　　Java 虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。

3 本地方法栈
    和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 
    在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、
    动态链接、出口信息。方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。

4 堆
    堆是Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，
    几乎所有的对象实例以及数组都在这里分配内存（目前由于编译器的优化，对象在堆上分配已经没有那么绝对了，
    参见：https://www.cnblogs.com/aiqiqi/p/10650394.html）。

　　Java 堆是垃圾收集器管理的主要区域，因此也被称作GC堆（Garbage Collected Heap）。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，
    所以Java堆还可以细分为：新生代和老年代：其中新生代又分为：Eden空间、From Survivor、To Survivor空间。进一步划分的目的是更好地回收内存，
    或者更快地分配内存。“分代回收”是基于这样一个事实：对象的生命周期不同，所以针对不同生命周期的对象可以采取不同的回收方式，以便提高回收效率。
    从内存分配的角度来看，线程共享的java堆中可能会划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。
    如图所示，JVM内存主要由新生代、老年代、永久代构成。

　　① 新生代（Young Generation）：大多数对象在新生代中被创建，其中很多对象的生命周期很短。每次新生代的垃圾回收（又称Minor GC）后只有少量对象存活，
  所以选用复制算法，只需要少量的复制成本就可以完成回收。

　　新生代内又分三个区：一个Eden区，两个Survivor区（一般而言），大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到两个Survivor区
  （中的一个）。当这个Survivor区满时，此区的存活且不满足“晋升”条件的对象将被复制到另外一个Survivor区。对象每经历一次Minor GC，年龄加1，
  达到“晋升年龄阈值”后，被放到老年代，这个过程也称为“晋升”。显然，“晋升年龄阈值”的大小直接影响着对象在新生代中的停留时间，在Serial和
  ParNew GC两种回收器中，“晋升年龄阈值”通过参数MaxTenuringThreshold设定，默认值为15。

　　② 老年代（Old Generation）：在新生代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代，该区域中对象存活率高。老年代的垃圾回收
  （又称Major GC）通常使用“标记-清理”或“标记-整理”算法。整堆包括新生代和老年代的垃圾回收称为Full GC（HotSpot VM里，除了CMS之外，
  其它能收集老年代的GC都会同时收集整个GC堆，包括新生代）。

　　③ 永久代（Perm Generation）：主要存放元数据，例如Class、Method的元信息，与垃圾回收要回收的Java对象关系不大。相对于新生代和年老代来说，
  该区域的划分对垃圾回收影响比较小。

　　在 JDK 1.8中移除整个永久代，取而代之的是一个叫元空间（Metaspace）的区域（永久代使用的是JVM的堆内存空间，而元空间使用的是物理内存，
  直接受到本机的物理内存限制）。


5 方法区
　　方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
  虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。

　　HotSpot 虚拟机中方法区也常被称为 “永久代”，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，
  这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存了。但是这并不是一个好主意，因为这样更容易遇到内存溢出问题。

　　相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。



每一条正在运行的线程都有自己的线程栈。线程栈包含了线程调用了什么方法来到达执行点的信息，
我称之为"调用堆栈"。当线程执行其代码，调用堆栈会改变。
线程栈包含每个方法的所有本地变量。线程只能访问自己的栈。
线程创建的局部变量对创建它的线程以外的所有其他线程都不可见。
即便是两个线程在执行相同的代码，两个线程将在自己栈产生局部变量。
每个线程都有自己局部变量的版本。
所有的基本数据类型的局部变量(byte,short,int,long,double,float,boolean,char)
都存储在栈里，对其他线程不可见。
一个线程可以将基本类型局部变量的副本快递给另一个线程，但他不能共享基本局部变量。


java垃圾回收

与C/C++相比，java语言不需要程序员直接控制内存回收，java程序的内存分配和回收都是由JRE在后台自动进行，JRE会负责回收那些不再使用的内存，这种机制被称为垃圾回收机制(Garbage Collection,GC)：

1.发现无用的对象；

2.回收被无用对象占用的内存空间，使之再次被程序使用(一般是在CPU空闲或者内存不足时)。

二、特点

1.垃圾回收机制的工作目标是回收无用对象的内存空间，这些内存空间都是jvm堆内存（运行时数据区，用以保存类的实例，即对象）里的内存空间，不包含其它物力资源，比如数据库连接、磁盘I/O等；

2.Java语言没有显式的提供分配内存和删除内存的方法，一些开发人员将引用对象设置为null或者调用System.gc()或者Runtime.getRuntime.gc()来释放内存(后两种方法仅是建议，慎重使用)；

3.垃圾回收不可预知，不同的jvm采用不同的垃圾回收机制和算法，有可能定时发生，有可能CPU空闲时发生，也有可能内存耗尽时发生(下面说下最为熟知的分代垃圾回收)；

三、分代垃圾回收（资料来自http://www.cnblogs.com/yaoyuan23/p/5587548.html）

1.年轻代（Young Generation）:

所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代分三个区。一个Eden区，两个Survivor区(一般而言)。大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个）（YGC，年轻代垃圾回收），当这个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当这个Survivor去也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制“年老区(Tenured)”。需要注意，Survivor的两个区是对称的，没先后关系，所以同一个区中可能同时存在从Eden复制过来 对象，和从前一个Survivor复制过来的对象，而复制到年老区的只有从第一个Survivor去过来的对象。而且，Survivor区总有一个是空的。同时，根据程序需要，Survivor区是可以配置为多个的（多于两个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。

2.年老代（Old Generation）:

在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。

3.持久代（Permanent Generation）:

用于存放静态文件，如今Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代大小通过-XX:MaxPermSize=<N>进行设置。

4.什么情况下触发垃圾回收

由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Minor GC和Full GC。

Minor GC

一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Minor GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。

Full GC

对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个对进行回收，所以比Full GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于Full GC的调节。有如下原因可能导致Full GC：

 年老代（Tenured）被写满

持久代（Perm）被写满

System.gc()被显示调用

上一次GC之后Heap的各域分配策略动态变化
